# 数字运算中的精度缺失问题
```js
console.log(0.1 + 0.2)  // 结果是0.30000000000000004，而不是3
```
在计算机中，数字无论是定点数还是浮点数都是以多位二进制的方式进行存储的。
## 10进制数是如何转化成2进制
```js
/* 十进度转2进制 */
//整数部分，除于2
8 --> 1000的过程：
8/2     余0
商4/2   余0
商2/2   余0
商1
结果：从商到余数倒数过去,1000

// 小数部分，跟十进制是一个道理，左边是除于10，右边是乘于10；同理，二进制左边是除于2，右边是乘于2
0.1 --> 0.0 0011 0011 ...
0.1*2=0.2   整数余0
0.2*2=0.4   整数余0
0.4*2=0.4   整数余0
0.8*2=1.6   整数余1
0.6*2=1.2   整数余1
之后循环部分：
0.2*2=0.4   整数余0
0.4*2=0.4   整数余0
0.8*2=1.6   整数余1
0.6*2=1.2   整数余1
可以看出，结果会无限循环，所以转换的结果为: 0.0 0011 0011 ...

可以推出：
0.2 --> 0.0011 0011 ...
```

## 在JS中采用的IEEE 754的双精度标准
IEEE 754 双精度版本(64位)将 64 位分为了三段
* 第一位用来表示符号
* 接下去的 11 位用来表示指数 其他的位数用来表示有效位，也就是用二进制表示 0.1 中的 10011(0011)

那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成 了 0.1 不再是 0.1 了，而是变成了 0.100000000000000002  
那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精 度变成了 0.200000000000000002，所以 0.1 +0.2 === 0.30000000000000004, 而不等于0.3

## 如何解决这个问题?
其实解决的办 法有很多，这里我们选用原生提供的方式来最简单的解决问题
```js
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
```

也可以：
```js
(0.1*100 +0.2*100)/100 === 0.3 // true
```