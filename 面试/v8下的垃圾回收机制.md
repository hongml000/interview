# V8 下的垃圾回收机制是怎么样的?
V8的垃圾回收策略基于分代回收机制。根据对象的存活时间将内存分为了新生代（new space）和老生代（old space），并对不同分代的内存采用不同的高效算法进行垃圾回收。

## 新生代算法
新生代中的对象一般存活时间较短，使用 Scavenge 算法进行垃圾回收。

主是要采用cheney算法，Cheney算法采用复制的方式进行垃圾回收。在新生代空间中，它将内存空间分为From 空间和 To 空间两部分。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象 并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。

* 缺点：Scavenge的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。
* 优点：新生代的对象生命周期短、存活对象少，复制成本不高，所以它在时间效率上有优异的表现。

## 对象晋升
当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代中的过程称为对象晋升
对象晋升有两个条件：
1. 对象是否经历过Scavenge回收
2. to空间的内存占用超过限制（25%）

## 老生代算法
老生代中的对象一般存活时间较⻓且数量也多，使用了两个算法，分别是 标记清除算法 和 标记压缩算法

## 标记-清除算法 
标记清除算法分为两个阶段，一阶段是标记，另一阶段是清除。与复制算法相比，标记－清除算法并不会将内存空间划分为两半，所以不存在浪费一半空间的行为。与复制算法不同的是，标记－清除算法在标记阶段遍历内存（堆）中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。可以看出复制算法只复制活着的对象，而标记－清除算法只清理死亡的对象。这是因为活对象在新生代中占较小部分，死对象在老龄代中占较小部分，这也是两种回收方式能高效工作的原因。

存在的问题：在进行一次标记清除回收后，内存空间会出现不连续的状态。这些内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大内存对象的情况，这时无法分配的情况下就会再次触发垃圾回收，而这次的回收是不必要的

## 标记-压缩算法
针对 标记-清除算法 的弊端，演变出了 标记-压缩算法。在标记阶段它们是一样的，只是对未标记对象处理方式不同，标记清除算法是对未标记对象执行清除，而标记压缩算法是将存活的对象往一端移动，在移动完成后，直接清理掉另一端内存。完成移动并清理完另一端内存后，老生代内存空间就是连续的未使用和已使用了，这样就可以进行大内存对象的分配了。

## 小结
由于Mark-Compact需要移动对象，所以执行速度上，比Mark-Sweep要慢。所以，V8主要使用Mark-Sweep算法，然后在当空间内存分配不足时，采用Mark-Compact算法。


## 全停顿 stop the world
垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「全停顿」（Stop The World）

## incremental Marking 增量标记
在新生代中，由于存活对象少，垃圾回收效率高，全停顿时间短，造成影响较小。  
但老生代中，存活对象多，而存活周期长，所以垃圾回收时间长，全停顿造成的影响大。长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。  
为减少全停顿时间，V8将标记进行了优化，使用增量标记，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会，这样交替多次完成标记。改进后的标记方式，最大停顿时间减少到原来的1/6  

# 总结
垃圾回收的原理较为复杂，在理解上需要花费一些功夫。了解GC原理，有助于我们对NodeJS项目进行性能瓶颈定位与调优。文章所描述的算法为V8中使用的基础算法，现代V8引擎对垃圾回收进行了很多改进，比如，在Chrome 64和Node.js v10中V8启用了「并行标记」技术，将标记时间缩短了60%~70%。还有「Parallel Scavenger」技术，它将新生代的垃圾回收时间缩短了20%~50%。

垃圾回收是影响服务性能的因素之一，为了提高服务性能，应尽量减少垃圾回收的次数。



参考:  
原文链接：https://blog.csdn.net/qbian/article/details/79367476
youthcity简书：https://www.jianshu.com/p/b8ed21e8a4fb