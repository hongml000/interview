# 事件的触发机制
在说明事件的触发机制时，先来了解事件冒泡、事件捕猎、事件委托（事件代理）、事件传播的概念。  

## 事件流和事件传播
* 事件流(Event Flow)：指的就是「网页元素接收事件的顺序」。  
* 事件传播：当一个事件发生后，会在子元素和父元素之间传播（按事件捕猎或事件冒泡顺序）  

## 事件冒泡
* 自下至上，即同一个事件，自触发元素事件开始，逐层向上触发事件，直至最外层元素（也就是点击当前元素，会触发子元素事件外，还会触其祖先元素的事件）。
* 事件默认的处理模式
```html
<!-- 这是一个例子 -->
<body>
  <div class="parent" style="height: 100px;width: 100px;background: red;">parent
    <p class="child" style="height: 50px;width: 50px;background: yellow;">child</p>
  </div>
  <script>
    var parent = document.getElementsByClassName('parent')[0];
    var child = document.getElementsByClassName('child')[0];
  </script>
</body>
```
```js
// 冒泡,点击child事件，会触发 child-->parent-->document的点击事件
document.addEventListener('click', function() {
      console.log('冒泡：点击document')
    }, false)
parent.addEventListener('click', function (e) {
    console.log('冒泡：点击parent')
    console.log(e.target);  // 点击child，可以看出，触发对象还是子元素，>>> <p class="child" style="height: 50px;width: 50px;background: yellow;">child</p>
  }, false)
child.addEventListener('click', function () {
    console.log('冒泡：点击child')
  }, false)

// 点击child对象
// >>>
// 点击child
// 点击parent
// 点击document
```
## 事件委托（事件代理）
利用事件冒泡和事件源对象处理的事件，即如果一个节点的子节点是动态生成的，那么在子节点需要注册事件的话应该注册在父节点上。

### 事件源对象
触发这个事件的源对象:
  * target 火狐
  * srcElement IE
  * chrome都有
```js
// onlick默认使用的是事件冒泡，这里的target是对源对象而言，不用因为事件冒泡而改变这个源对象
child.onclick = function(e){
    //window.event是IE浏览器的
    var event = e || window.event;
    var child = e.target || e.srcElement;
    console.log(child);        //点击child，出现<p class="child" style="height: 50px;width: 50px;background: yellow;">child</p>
}
```

### 事件代理的应用
```html
<div class="wraper">
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
        <li>6</li>
        <li>7</li>
        <li>8</li>
        <li>9</li>
        <li>10</li>
    </ul>
</div>
<script>
// 原来使用循环遍历的方法
liList = document.getElementsByTagName('li');
console.log(liList);
len  = liList.length;
console.log(len);
for(var i=0; i<len-1; i++){
    liList[i].onclick = function(){
        console.log(this.innerText);
    }
}
//有多少个li，就要遍历多少个增加事件
//如果后面动态加li，那么又得重写for循环加事件

// 利用事件冒泡和事件源对象优化,li.onclick会默认冒泡到ul上
var ul = document.getElementsByTagName('ul')[0];
ul.onclick = function(e){
    //兼容IE
    var event = e || window.event;
    //兼容火狐和IE
    var target = e.target || e.srcElement;
    console.log(target.innerText);
}
</script>
```
优点：
* 性能，不需要遍历所有子元素，一个个绑定事件，节省内存
* 灵活，当有新的子元素时不需要重新绑定事件和注销事件

## 事件捕获
* 自上向下，直至当前触发对象，即同一个事件，会从最外层document开始触发事件，逐层往下触发其子元素事件，直至到当前元素为止。
```js
// 捕获
document.addEventListener('click', function () {
    console.log('捕获：点击document')
  }, true)
parent.addEventListener('click', function () {
  console.log('捕获：点击parent')
}, true)
child.addEventListener('click', function () {
  console.log('捕获：点击child')
}, true)

// 点击child对象
// >>>
// 点击document
// 点击parent
// 点击child

// 点击parent对象
//>>>
// 点击document
// 点击parent
```

### 事件触发机制
事件的触发顺序如下：
1. 捕获阶段：事件从window对象自上而下向目标节点传播的阶段；
2. 目标阶段：按照程序定义的顺序执行触发的事件
3. 冒泡阶段：事件从目标节点自下而上向window对象传播的阶段
```js
// 冒泡
document.addEventListener('click', function() {
  console.log('冒泡：点击document')
}, false)
parent.addEventListener('click', function () {
    console.log('冒泡：点击parent')
  }, false)
child.addEventListener('click', function () {
    console.log('冒泡：点击child')
  }, false)

// 捕获
document.addEventListener('click', function () {
    console.log('捕获：点击document')
  }, true)
  parent.addEventListener('click', function () {
    console.log('捕获：点击parent')
  }, true)
  child.addEventListener('click', function () {
    console.log('捕获：点击child')
  }, true)

// 点击child
// >>>
// 捕获：点击document
// 捕获：点击parent
// 冒泡：点击child
// 捕获：点击child
// 冒泡：点击parent
// 冒泡：点击document

// 除了child本身，是先捕获后冒泡，到了child本身，按执行顺序是先有事件冒泡，再有事件捕获的
```

# 事件的绑定或解除
## 事件的绑定
### target.onxxx = function() {...}
* 兼容性好，但一个元素上一个事件只能绑定一个程序
* 基本等同于写在HTML行间上
* 程序this指向元素本身
```js
div.onclick = function(){
    div.innerText = "我被点击了！！";
    console.log(this);      //div元素本身
}
```
### target.addEventListener(type,fn,useCapture)
obj.addEventListener(事件类型，处理函数，是否使用捕获)
* IE9以下不兼容（IE9以下不兼容一般都是W3Cschool标准），可为一个事件绑定多个处理程序
* 多个处理函数，每次执行顺序按定义的顺序执行
* 程序this指向元素本身
```js
div.addEventListener('click',function(){
    console.log('a');
    console.log(this);      //div元素本身
},false)
```

### obj.attachEvent('on'+type,fn)
* IE独有，一个事件同样可绑定多个处理程序
* 程序this指向window
```js
div.attachEvent('onclick',function(){
    console.log(this);      //window
})

//想让this指南元素本身的话
var div = document.getElementsByTagName('div')[0];
div.attachEvent('onclick',function(){
    func.call(div);
})
function func(){
    console.log(this);
}
```

### 封装事件绑定,兼容所有情况
```js
// 封装事件绑定
function addEvent(elem, type, handle){
    if(elem.addEventListener){
        elem.addEventListener(type,handle,false);
    }else if(elem.attachEvent){
        elem.attachEvent('on' + type, function (){
            handle.call(elem);
        });
    }else{
        elem['on'+type] = handle;
    }
}
``` 

## 解除绑定事件

### elem.onclick
```js
elem.onclick = false || '' || null;
``` 

### elem.removeEventListener(type,func,false)
```js
div.addEventListener('click',test = function(){
    console.log(this);
    div.removeEventListener('click',test,false);
},false)
``` 

### elem.removeAttachEvent(type,func)
```js
div.attachEvent('click',test = function(){
    func.call(div);
    div.removeAttachEvent('click',test)
})
function func(){
    console.log(this);
}
``` 